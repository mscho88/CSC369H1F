#!/bin/bash

# Execute the matmul with a parameter 100
matmul="`valgrind --tool=lackey --trace-mem=yes simpleloop |& grep -e \"I \" -e \"S \" -e \"L \" -e \"M \"`"

# Read the memory address of the MARKER_START and the MARKER_END
marker_start="`cat .marker | sed 's/ /\n/g' | sed -n 1p | cut -c4-`"
marker_end="`cat .marker | sed 's/ /\n/g' | sed -n 2p | cut -c4-`"

I=0			# Number of the memory access of the instruction read
S=0			# Number of the memory access of the data storing
L=0			# Number of the memory access of the data loading
M=0			# Number of the memory access of the data modification
MA1=0		# Number of the memory access before the MARKER_START
MA2=0		# Number of the memory access between the MARKER_START and
			# the MARKER_END
MA3=0		# Number of the memory access after the MARKER_END
pivot=0		# Pivot point where the MARKER_START and the MARKER_END
			# reached

# Check the execution of the matmul with a parameter 100 in line by line
for line in `echo $matmul | sed 's/I /I/g' | sed 's/S /S/g' | sed 's/L /L/g' | sed 's/M /M/g' | sed 's/ /\n/g'`
do
	var="${line:0:1}"
	
	# Check how the memory access occurs
	if [ $var == "I" ]
	then
		# If the line is start with I, then it is the instruction read
		I=$((I + 1))
	elif [ $var == "S" ]
	then
		# If the line is start with S, then it is the data storing
		S=$((S + 1))
	elif [ $var == "L" ]
	then
		# If the line is start with L, then it is the data loading
		L=$((L + 1))
	elif [ $var == "M" ]
	then
		# If the line is start with M, then it is the data modification
		M=$((M + 1))
	fi
	
	# Check when the MARKER_START and the MARKER_END are accessed
	if [ $pivot -eq 0 ]
	then
		MA1=$((MA1 + 1))
		
		# If the line represents the memory access of MARKER_START,
		# increase the pivot by 1. From this point, counting the number
		# of memory access before the MARKER_START ends.
		if test "${line#*$marker_start}" != "$line"
		then
			pivot=$((pivot + 1))
		fi
	elif [ $pivot -eq 1 ]
	then
		MA2=$((MA2 + 1))
		
		# If the line represents the memory access of MARKER_END,
		# increase the pivot by 1. From this point, counting the number
		# of the memory access after the MARKER_START and before the
		# MARKER_END finishes
		if test "${line#*$marker_end}" != "$line"
		then
			pivot=$((pivot + 1))
		fi
	else
		# Count the number of the memory access after the MARKER_END.
		MA3=$((MA3 + 1)) 
	fi
done

echo $I $S $L $M $MA1 $MA2 $MA3

echo $matmulI $matmulS $matmulL $matmulM $matmulMAa $matmulMAb $matmulMAc | awk 'BEGIN {printf("\n %s\t|%s\t\t|%s\t|%s\n" ,"Code pages", "Data pages", "MemoryAccess1", "MemoryAccess")}
{printf(" --------------------------------------------------------------------\n" )}
{printf(" %s\t\t|%s\t%s\t%s\t|%s\t%s\t|%s\n" ,"I", "S", "L", "M", "before", "after", "between")}
{printf(" %d\t\t|%d\t%d\t%d\t|%d\t%d\t|%d\n", $1, $2, $3, $4, $5, $6, $7)}'
echo $blockedI $blockedS $blockedL $blockedM $blockedMAa $blockedMAb $blockedMAc | awk 'BEGIN {printf(" %d\t\t|%d\t%d\t%d\t|%d\t%d\t|%d\n", $1, $2, $3, $4, $5, $6, $7)}
{printf("\n")}'
